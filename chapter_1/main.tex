\section{Domain Analysis}

\subsection{User Interfaces and Input Devices}

% Before diving in the deeps of real-time communication over the Web, it is necessary to review the path that people took in order to interact with computers in the first place.

At the very beginning of the computer era, the devices that we now know as
PCs, laptops and tablets were immense pieces of machinery that occupied entire
laboratories and only highly qualified individuals had access to them. These
machines where developed in order to perform various numerical problems by
executing digital computations. As the saying goes, a machine can only do what
a man tells it to do, so engineers had to come up with different means to set
tasks for these electronic beasts, that is, a need for \emph{user interfaces}
arouse. Operators used large stacks of punched cards to feed instructions and
data sets to computers. These punched cards in turn where created using
specialized devices that also required some knowledge in the field. Over all
it was a complex process that couldn't be easily grasped by an ordinary
persons. At that time, however, the majority of computer user had PhDs and
were trained to perform these very tasks so the difficulty of communicating
with machines wasn't really a great problem.

% picture of ENIAC maybe

In time, the interest towards computers grew bigger among enthusiasts while
the devices themselves where becoming smaller and smaller, eventually giving
birth to the term of 'microcomputer'. Among the first microcomputers to get
widespread popularity was the critically acclaimed Altair 8080 which
represented a box with lights and switches on the front panel that where used
to feed data and instructions into the computer and read the results back from
it.

% picture of Altair 8080 front panel

As more hobbyists took a hold of such devices people discovered many uses for
them beyond that of performing various mathematical operations. They learned
how to connect teletypes to computers and this way the later got an interface
that is familiar to all of us today, a keyboard. For some time people
interacted with computers using command lines, but with the development of
computer graphics and the creation of graphical user interfaces, a need for a
new kind of controller appeared, specifically the need for a pointing device.
Since then, a standard personal computer included a mouse and a keyboard among
it's peripheral devices.

\subsubsection{Input Devices for Gaming}

On the other hand, the development of input devices never stopped with the
creation of the mouse and keyboard. A wealth of specialized devices was
created to perform tasks that were specific to a particular use of the
computer. One of the most notable fields that was moving the development of
specialized peripherals was and still is the \emph{game development industry}.
During the years, various types of controllers were developed, some of them
are listed below:

\begin{description}

	\item [Gamepad] is a general-purpose gaming device that is used as a
		controller for a wide range of game genres, from arcades and fighting
		games to role-playing titles and action third-person shooters.

	\item [Joystick] is a specialized controller that is often used in flight
		simulation games, although its use can be extended far beyond gaming, for such
		purposes as remote control of a robot arm in a warehouse.

	\item [Steering Wheel] is used to provide almost authentic driving
		experience in racing video games and simulators. \end{description}

% picture of stuff mentioned above

% include info about Nintendo Wii

\subsection{Mobile User Interfaces}

Very soon, technological progress made it possible to stick microcomputers
virtually in any device, be it a fridge, microwave oven or a car. The most
benefit out of this, however, gained the industry of mobile phones, eventually
giving birth to the concept of smart-phones. Today, almost every person living
in a more or less civilized region of the world has in his/her pocket a little
'brick' with the computer power thousands of times greater than the one that
was used to send people to the moon. This breakthrough in portable computing
facilitated the development of software for such devices and the majority of
companies started to support mobile applications where it made sense.

In the context of user interface design and input handling techniques,
developers found themselves in a completely different world. Nobody would
carry a mouse and a keyboard in order to interact with the phone, instead,
people would use the number pad plus a couple of additional buttons present on
the phone. In time, another revolution took place, it was the moment when
touch screens became reality. Once again, developers had to think their way
through these changes and create user interfaces that would suit fingers
poking into the screen rather than button clicks. With the difficulties of
user interface redesign for touch devices came also a wide range of new
possibilities. Now that the whole screen constituted an input device, the
users could perform gestures like taps, swipes, pan motions, pinch-zoom
actions. These gestures made the process of using an application a great deal
more intuitive when compared to the times when every action was performed
through the click of a certain button.

Besides touch screens, mobile phone vendors began to include in their devices
such sensors like accelerometers and gyroscopes. Accelerometers are used to
catch the moment when the device is moved and to calculate the direction and
acceleration of such movement. On the software side this could be used in
various ways, the simplest being to switch to the next song in the music
player by jerking the phone to the right. Meanwhile, gyroscopes where designed
to capture the orientation of the device at a given moment in time. This
functionality is employed every time the phone is tilted over 90 degrees and
triggers the switch between landscape and portrait view modes.

When it came to the industry of mobile gaming, touch screens and sensors that
could capture the motion and orientation of the device were a really big deal,
because they opened the possibilities for developing complex user interfaces
that would simulate specialized gaming devices. The accelerometer and
gyroscope would be used as the steering wheel in racing games while the touch
screen would capture taps in various regions and interpret them as clicks of
different buttons of a gamepad, whose simplified image would be rendered on
the same screen.

% picture of mobile game UI which resembles a gamepad

\subsection{Mobile Devices as Controllers for Desktop Computers}

When comparing the features of a specialized gaming device like \emph{Nintendo
Wii} Controller and the capabilities of a modern smart-phone, an interesting
pattern of similarities can be observed. Both are able to capture device
motion and position. Both respond to clicks of buttons in case of a gamepad
and taps in designated areas in case of a phone. Touch screens can be used to
simulate even the motion of a joystick, by capturing swipe or pan gestures.
One feature that a specialized gaming device may have, that a phone falls
short of, is ergonomics, but to a certain extent this can be neglected. With
such a list of similarities, a logical question appears: Why not use mobile
phones as gaming controllers for desktop games?

\subsubsection{The Problem}

As it turns out, now that smart-phones run full-fledged operating systems,
connecting one to a computer is not that hard of a task. Mobile operating
systems like Android, Apple iOS and Windows Mobile, all support socket
programming, thus a programmer can setup a communication channel over the
network between a mobile phone and a laptop connected to the same Wi-Fi
hotspot. They can even be located on different sides of the planet, it is
sufficient to have an Internet connection to be able to exchange data between
devices.

Overall it looks like a way to go approach. On the other hand, there are some
problems with it that are not to be observed at first sight. In the first
place, every time that a company wants to create a game with support for
mobile devices as controllers, the developers will have to write custom mobile
applications in addition to the main game, they will also have to devise
specialized communication protocols. This is both, time and money consuming
and is not economically convenient. Secondly, there is a problem on the user
side which is best illustrated with a situation. Let's suppose a party or a
team-building event where the host tries to entertain his guests with a
multiplayer computer game. Not everyone has at home a gaming platform like
Sony Playstation or Microsoft Xbox, neither does anyone have more than 2-3 PC
gamepads. In this situation, the ability to use smart-phones as controllers
would be a great benefit. In case the connection is implemented in the way
described above, a gaming party would transform into a setup party, where
guests would spend a lot of time installing mobile applications that are
probably needed only for one-time use and don't hold any value by themselves
without the main game. Fortunately both problems can be solved relatively
simple through the same solution.

\subsubsection{The Solution}

One thing that all modern smart-phones have in common is a decent web browser.
Today, browsers are more than just viewers of HTML documents, they are entire
ecosystems and programming environments that are almost independent of the
underlying operating system. The fact that every mobile phone has such an
environment makes it possible to write cross-platform application served on
the web that would otherwise be installed manually as a native app. Modern
browsers support APIs that can interact with various parts of a mobile device
like accelerometer, gyroscope and touch screen, exactly the things that are
necessary to simulate a fully functional gaming device.

Having said this, one thing that could solve the problems stated in the
section above may be a framework or toolkit that unifies in a single library
all the APIs that are necessary to connect a mobile phone to a computer as a
remote gaming controller. It would make it easier and faster to develop games
with such a feature. This toolkit may also include user interface building
blocks which can be combined to create custom controllers.

The purpose of this thesis is to create a simple web-based multiplayer
isometric arcade called 'Snowfight'. The main game is started by accessing its
web page. The first thing the players see is a lobby and a connection URL.
Players join the game by navigating to the provided URL using the browsers
installed on their phones. When enough players have connected and the
participants decide to start the game, a button can be clicked on the main
game screen. The game play concept is rather simple, players can move their
characters around the game space and throw snowballs in each other using the
controls rendered by the web application that works on their phones. Every
player has a certain amount of hit points (HP) and if a player is hit, his HP
amount decreases. When a player's HP amount reaches zero, he is eliminated
from the game. The goal of the game is to eliminate all players from the
adversary team.

In order to implement this project it is necessary to explore the topic of
real-time communication in web, as to be able to chose the right technology
that would provide a smooth and responsive gaming experience.




\subsection{Real-Time Communication over the Web} % about communication technologies

One of the main uses of the Internet is hosting and accessing web pages. When a
user writes a URL in the browser's search bar and presses 'enter', the browser
preforms an HTTP request to the server specified by the URL and fetches a web
page. At this point in time, for most cases, the communication between the
server and the client (browser) is ceased until the user clicks on another link
that would restart the process.

On the other hand, modern web has greatly developed during the past few years.
Internet connection speed has increased dramatically, and many websites have
stopped being just static web pages and have moved towards a more dynamic model.
They are not even called websites, today, all around the world there are web
applications.

With the requirements for a more dynamic web came also the technical challenges
of making it so. For instance, how would a user's browser receive a notification
about a message that was sent to this user from another part of the globe? When
such questions just appeared, developers tried different techniques using the
old tools they had at hand at that time. The concepts of HTTP Long Polling and
HTTP Streaming appeared in this period. Soon, however, they were found to be
causing quite a bit of issues\cite{long_polling_issues} and a need for custom
protocols arose.

As the web is mainly composed of clients and servers, the logical outcome was a
protocol that would connect them and would permit bidirectional communication
between the server and its clients, thus WebSockets were proposed. At the same
time, browsers grew and their uses extended. Soon, real-time communication out-
sized the context of client-server architecture and when video chat applications
and multiplayer games started to conquer the web realm, engineers developed
WebRTC, which solved the issue of communication in peer-to-peer setups. A brief
description of both protocols as per their RFCs is presented in the sections
that follow.

\subsubsection{WebSockets for Client-Server Communication} % Websockets

Historically, creating web applications that need bidirectional communication
between a client and a server (e.g., instant messaging and gaming applications)
has required an abuse of HTTP to poll the server for updates while sending
upstream notifications as distinct HTTP calls.

As RFC6455\cite{websockets} points out, this results in a variety of problems:

\begin{itemize}

\item The server is forced to use a number of different underlying TCP
  connections for each client: one for sending information to the
  client and a new one for each incoming message.

\item The wire protocol has a high overhead, with each client-to-server
  message having an HTTP header.

\item The client-side script is forced to maintain a mapping from the
  outgoing connections to the incoming connection to track replies.

\end{itemize}

A simpler solution would be to use a single TCP connection for traffic in both
directions. This is what the WebSocket Protocol provides. Combined with the
WebSocket API, it provides an alternative to HTTP polling for two-way
communication from a web page to a remote server.

The same technique can be used for a variety of web applications: games, stock
tickers, multiuser applications with simultaneous editing, user interfaces
exposing server-side services in real time, etc.

The WebSocket Protocol is designed to supersede existing bidirectional
communication technologies that use HTTP as a transport layer to benefit from
existing infrastructure (proxies, filtering, authentication). Such technologies
were implemented as trade-offs between efficiency and reliability because HTTP
was not initially meant to be used for bidirectional communication. The
WebSocket Protocol attempts to address the goals of existing bidirectional HTTP
technologies in the context of the existing HTTP infrastructure; as such, it is
designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies
and intermediaries, even if this implies some complexity specific to the current
environment. However, the design does not limit WebSocket to HTTP, and future
implementations could use a simpler handshake over a dedicated port without
reinventing the entire protocol. This last point is important because the
traffic patterns of interactive messaging do not closely match standard HTTP
traffic and can induce unusual loads on some components.


\subsubsection{WebRTC for Peer to Peer Communication} % WebRTC

\newpage

% \subsection{Mobile devices Game Controllers} % game controllers + web

% \subsubsection{Native Apps}

% \subsubsection{Web Apps}

\subsection{Solutions on the Market}

\subsubsection{Lightsaber Escape} % https://lightsaber.withgoogle.com/

\newpage

\subsubsection{Super Sync Sports} % https://www.chrome.com/supersyncsports/

\newpage

\subsection{Project Description}

\newpage

\subsection{Domain Analysis Conclusions}

\newpage

\clearpage
